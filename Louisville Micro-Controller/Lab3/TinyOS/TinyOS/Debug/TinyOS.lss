
TinyOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000d0  00800100  00000456  000004ea  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000456  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000b  008001d0  008001d0  000005ba  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000005ba  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000005ec  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000080  00000000  00000000  00000630  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000ec9  00000000  00000000  000006b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009c9  00000000  00000000  00001579  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000711  00000000  00000000  00001f42  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000c8  00000000  00000000  00002654  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000500  00000000  00000000  0000271c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000000dd  00000000  00000000  00002c1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000050  00000000  00000000  00002cf9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
   4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  18:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  24:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  28:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  30:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  34:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  38:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  48:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  7c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  80:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  84:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  88:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  8c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  90:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  94:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  98:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  9c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  ac:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  b0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>

000000b4 <__ctors_end>:
  b4:	11 24       	eor	r1, r1
  b6:	1f be       	out	0x3f, r1	; 63
  b8:	cf ef       	ldi	r28, 0xFF	; 255
  ba:	d8 e0       	ldi	r29, 0x08	; 8
  bc:	de bf       	out	0x3e, r29	; 62
  be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
  c0:	11 e0       	ldi	r17, 0x01	; 1
  c2:	a0 e0       	ldi	r26, 0x00	; 0
  c4:	b1 e0       	ldi	r27, 0x01	; 1
  c6:	e6 e5       	ldi	r30, 0x56	; 86
  c8:	f4 e0       	ldi	r31, 0x04	; 4
  ca:	02 c0       	rjmp	.+4      	; 0xd0 <UDR0+0xa>
  cc:	05 90       	lpm	r0, Z+
  ce:	0d 92       	st	X+, r0
  d0:	a0 3d       	cpi	r26, 0xD0	; 208
  d2:	b1 07       	cpc	r27, r17
  d4:	d9 f7       	brne	.-10     	; 0xcc <UDR0+0x6>

000000d6 <__do_clear_bss>:
  d6:	21 e0       	ldi	r18, 0x01	; 1
  d8:	a0 ed       	ldi	r26, 0xD0	; 208
  da:	b1 e0       	ldi	r27, 0x01	; 1
  dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
  de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
  e0:	ab 3d       	cpi	r26, 0xDB	; 219
  e2:	b2 07       	cpc	r27, r18
  e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
  e6:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <main>
  ea:	0c 94 29 02 	jmp	0x452	; 0x452 <_exit>

000000ee <__bad_interrupt>:
  ee:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f2 <Mega328P_Init>:
.section ".text"					//student comment here 

.global Mega328P_Init 

Mega328P_Init: 
		ldi	r16,0x07			;PB0(R*W),PB1(RS),PB2(E) as fixed 							;outputs 
  f2:	07 e0       	ldi	r16, 0x07	; 7

		out	DDRB,r16			//initialize data register for port b 
  f4:	04 b9       	out	0x04, r16	; 4

		ldi	r16,0				//student comment here 
  f6:	00 e0       	ldi	r16, 0x00	; 0

		out	PORTB,r16			//Initalize Port B 
  f8:	05 b9       	out	0x05, r16	; 5

		out	U2X0,r16			;initialize UART, 8bits, no parity, 1 stop, 							;9600 
  fa:	01 b9       	out	0x01, r16	; 1

		ldi	r17,0x0				//Set register 17 and 16 to 0x0067 
  fc:	10 e0       	ldi	r17, 0x00	; 0

		ldi	r16,0x67			//Set register 17 and 16 to 0x0067 
  fe:	07 e6       	ldi	r16, 0x67	; 103

		sts	UBRR0H,r17			//Baud rates high and low equal to r17 and 							// 16 (103) 
 100:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>

		sts	UBRR0L,r16			//Baud rates high and low equal to r17 and 							// 16 (103) 
 104:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>

		ldi	r16,24				// Bits 2 and 5 high 
 108:	08 e1       	ldi	r16, 0x18	; 24

		sts	UCSR0B,r16			//Setting character size and Data Register 							// Interrupt flag 
 10a:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>

		ldi	r16,6				// Bits 1 and 2 high  
 10e:	06 e0       	ldi	r16, 0x06	; 6

		sts	UCSR0C,r16			//Setting parity, clock phase, data order, and 							// stop bit 
 110:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>

		ldi 	r16,0x87		//initialize ADC 
 114:	07 e8       	ldi	r16, 0x87	; 135

		sts 	ADCSRA,r16		//Enables the ADC and sets the prescalars 
 116:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7f807a>

		ldi 	r16,0x40		// bit 7 high 
 11a:	00 e4       	ldi	r16, 0x40	; 64

		sts 	ADMUX,r16		// Set internal voltage reference 
 11c:	00 93 7c 00 	sts	0x007C, r16	; 0x80007c <__TEXT_REGION_LENGTH__+0x7f807c>

		ldi 	r16,0			// All pins low 
 120:	00 e0       	ldi	r16, 0x00	; 0

		sts 	ADCSRB,r16		// All pins low 
 122:	00 93 7b 00 	sts	0x007B, r16	; 0x80007b <__TEXT_REGION_LENGTH__+0x7f807b>

		ldi 	r16,0xFE		// bits 1-7 high 
 126:	0e ef       	ldi	r16, 0xFE	; 254

		sts 	DIDR0,r16		// Turn off all ADC's except the one being 							// used (pin 0) This saves power 
 128:	00 93 7e 00 	sts	0x007E, r16	; 0x80007e <__TEXT_REGION_LENGTH__+0x7f807e>

		ldi 	r16,0xFF		// All Pins high 
 12c:	0f ef       	ldi	r16, 0xFF	; 255

		sts 	DIDR1,r16		// Disables all pins, saves power 
 12e:	00 93 7f 00 	sts	0x007F, r16	; 0x80007f <__TEXT_REGION_LENGTH__+0x7f807f>

		ret						// leave subroutine when finished  
 132:	08 95       	ret

00000134 <LCD_Write_Command>:

.global LCD_Write_Command 

LCD_Write_Command: 

	call		UART_Off			// LCD requires access to the UART dual 							// ports, must disable the UART ports to use 							// the LCD 
 134:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>

	ldi		r16,0xFF			;PD0 - PD7 as outputs 
 138:	0f ef       	ldi	r16, 0xFF	; 255

	out		DDRD,r16			// Enables all pins on this port for use 
 13a:	0a b9       	out	0x0a, r16	; 10

	lds		r16,DATA			// Store the DATA into r16 
 13c:	00 91 d0 01 	lds	r16, 0x01D0	; 0x8001d0 <__data_end>

	out		PORTD,r16			// Store the DATA into port D 
 140:	0b b9       	out	0x0b, r16	; 11

	ldi		r16,4				// Enable only the third pin for port B 
 142:	04 e0       	ldi	r16, 0x04	; 4

	out		PORTB,r16			// Enable only the third pin for port B 
 144:	05 b9       	out	0x05, r16	; 5

	call		LCD_Delay			// Delay the LCD to write 
 146:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>

	ldi		r16,0				// Disable Port B 
 14a:	00 e0       	ldi	r16, 0x00	; 0

	out		PORTB,r16			// Disable Port B 
 14c:	05 b9       	out	0x05, r16	; 5

	call		LCD_Delay			// Delay LCD again 
 14e:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>

	call		UART_On			// Enable UART ports when writing is 							// finished 
 152:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>

	ret						// leave subroutine when finished  
 156:	08 95       	ret

00000158 <LCD_Delay>:

  

LCD_Delay: 

	ldi	r16,0xFA				// store r16 with a very large number 
 158:	0a ef       	ldi	r16, 0xFA	; 250

0000015a <D0>:

D0:	ldi	r17,0xFF				// store r17 with an even larger number = 
 15a:	1f ef       	ldi	r17, 0xFF	; 255

0000015c <D1>:

D1:	dec	r17					// decrement r17 
 15c:	1a 95       	dec	r17

	brne	D1					// Continue decrementing r17 until it is equal 							 // to r16 
 15e:	f1 f7       	brne	.-4      	; 0x15c <D1>

	dec	r16					// Now decrement r16 
 160:	0a 95       	dec	r16

	brne	D0					// Repeat this process again until equal 
 162:	d9 f7       	brne	.-10     	; 0x15a <D0>

	ret						// Creates a small loop that takes a while to 							// complete 
 164:	08 95       	ret

00000166 <LCD_Write_Data>:

.global LCD_Write_Data 

LCD_Write_Data: 

	call	UART_Off				// USART must be turned off to use the 							// LCD 
 166:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>

	ldi	r16,0xFF				// All pins high 
 16a:	0f ef       	ldi	r16, 0xFF	; 255

	out	DDRD,r16				// Enable all data registers for D 
 16c:	0a b9       	out	0x0a, r16	; 10

	lds	r16,DATA				// store data into r16 
 16e:	00 91 d0 01 	lds	r16, 0x01D0	; 0x8001d0 <__data_end>

	out	PORTD,r16				// store data into PORT D 
 172:	0b b9       	out	0x0b, r16	; 11

	ldi	r16,6					// set pins 1 and 2 high 
 174:	06 e0       	ldi	r16, 0x06	; 6

	out	PORTB,r16				// Enable pins 1 and 2 for PORT B 
 176:	05 b9       	out	0x05, r16	; 5

	call	LCD_Delay				// Delay LCD for writing 
 178:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>

	ldi	r16,0					// Disable PORT B 
 17c:	00 e0       	ldi	r16, 0x00	; 0

	out	PORTB,r16				// Disable PORT B 
 17e:	05 b9       	out	0x05, r16	; 5

	call	LCD_Delay				// Delay LCD again 
 180:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>

	call	UART_On				// re-enable UART after finished with LCD 
 184:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>

	ret						// leave subroutine when finished 
 188:	08 95       	ret

0000018a <LCD_Read_Data>:

.global LCD_Read_Data 

LCD_Read_Data: 

	call		UART_Off			// Disable UART when using LCD 
 18a:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>

	ldi		r16,0x00			// ALL data registers disabled for D 
 18e:	00 e0       	ldi	r16, 0x00	; 0

	out		DDRD,r16			// ALL data registers disabled for D 
 190:	0a b9       	out	0x0a, r16	; 10

	out		PORTB,4			// Enable pin 3 for B 
 192:	45 b8       	out	0x05, r4	; 5

	in		r16,PORTD			// Read PORTD input and write into r16 
 194:	0b b1       	in	r16, 0x0b	; 11

	sts		DATA,r16			// store this value into DATA 
 196:	00 93 d0 01 	sts	0x01D0, r16	; 0x8001d0 <__data_end>

	out		PORTB,0			// DISABLE port B 
 19a:	05 b8       	out	0x05, r0	; 5

	call		UART_On			// Re-enable USART when finished 
 19c:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>

	ret						// leave subroutine when finished 
 1a0:	08 95       	ret

000001a2 <UART_On>:

.global UART_On 

UART_On: 

	ldi	r16,2					//initializes port D 
 1a2:	02 e0       	ldi	r16, 0x02	; 2

	out	DDRD,r16				//initializes port D 
 1a4:	0a b9       	out	0x0a, r16	; 10

	ldi	r16,24					// Enable bits 2 and 5 
 1a6:	08 e1       	ldi	r16, 0x18	; 24

	sts	UCSR0B,r16				// Enables character size and data registry 							// interrupt 
 1a8:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>

	ret						// leave subroutine when finished 
 1ac:	08 95       	ret

000001ae <UART_Off>:

.global UART_Off 

UART_Off: 

	ldi	r16,0					// Turn all pins off 
 1ae:	00 e0       	ldi	r16, 0x00	; 0

	sts 	UCSR0B,r16				// Sets USART pins off 
 1b0:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>

	ret						// leave subroutine when finished 
 1b4:	08 95       	ret

000001b6 <UART_Clear>:

.global UART_Clear 

UART_Clear: 

		lds	r16,UCSR0A			// read UCSR0A pins and save to r16 
 1b6:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>

		sbrs	r16,RXC0			// Checks if parity, doubled transmission 							// speed, and parity error are enabled 
 1ba:	07 ff       	sbrs	r16, 7

		ret					// Leave subroutine if not 
 1bc:	08 95       	ret

		lds	r16,UDR0			// store any USART data into r16 
 1be:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>

		rjmp	UART_Clear			// Loop to finalize clearing 
 1c2:	f9 cf       	rjmp	.-14     	; 0x1b6 <UART_Clear>

000001c4 <UART_Get>:

.global UART_Get 

UART_Get: 

		lds	r16,UCSR0A			// read UCSR0A pins and save to r16 
 1c4:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>

		sbrs	r16,RXC0			// Checks if parity, doubled transmission speed, and parity error are enabled 
 1c8:	07 ff       	sbrs	r16, 7

		rjmp	UART_Get			// If not error and loop 
 1ca:	fc cf       	rjmp	.-8      	; 0x1c4 <UART_Get>

		lds	r16,UDR0			// store any USART data into r16 (the information you are getting) 
 1cc:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>

		sts	ASCII,r16			// store this data into ASCII variable 
 1d0:	00 93 d2 01 	sts	0x01D2, r16	; 0x8001d2 <ASCII>

		ret					// leave subroutine when finished 
 1d4:	08 95       	ret

000001d6 <UART_Put>:

.global UART_Put 

UART_Put: 

		lds	r17,UCSR0A			// read all pins active in UCSR0A and save them to r17 
 1d6:	10 91 c0 00 	lds	r17, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>

		sbrs	r17,UDRE0			// checks if the USART port is set to 								//communication mode (for reading and 							//wiritng) and there is no parity error 
 1da:	15 ff       	sbrs	r17, 5

		rjmp	UART_Put			// If not error and loop 
 1dc:	fc cf       	rjmp	.-8      	; 0x1d6 <UART_Put>

		lds	r16,ASCII			// Loads the most recent ASCII string to r16 
 1de:	00 91 d2 01 	lds	r16, 0x01D2	; 0x8001d2 <ASCII>

		sts	UDR0,r16			// Stored this value to Data Register 0 for 							// displaying 
 1e2:	00 93 c6 00 	sts	0x00C6, r16	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>

		ret					// leave subroutine when finished 
 1e6:	08 95       	ret

000001e8 <ADC_Get>:

.global ADC_Get 

ADC_Get: 

		ldi	r16,0xC7			// pins 0,1,2,6,and 7 high 
 1e8:	07 ec       	ldi	r16, 0xC7	; 199

		sts	ADCSRA,r16			// Loads the ADC Prescalar, enables the							// ADC, then starts the first conversion 
 1ea:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7f807a>

000001ee <A2V1>:

A2V1:		lds	r16,ADCSRA			// Loads the ADCSRA pins to r16 
 1ee:	00 91 7a 00 	lds	r16, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7f807a>

		sbrc	r16,ADSC			// Checks if prescalar division factor is 8 
 1f2:	06 fd       	sbrc	r16, 6

		rjmp 	A2V1				// If not error and loop  
 1f4:	fc cf       	rjmp	.-8      	; 0x1ee <A2V1>

		lds	r16,ADCL			// Loads ADC low bit data into r16 
 1f6:	00 91 78 00 	lds	r16, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7f8078>

		sts	LADC,r16			// Stores this value into LADC 
 1fa:	00 93 d8 01 	sts	0x01D8, r16	; 0x8001d8 <LADC>

		lds	r16,ADCH			// Loads ADC high bit data into r16 
 1fe:	00 91 79 00 	lds	r16, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7f8079>

		sts	HADC,r16			// Stores this value into HADC 
 202:	00 93 d1 01 	sts	0x01D1, r16	; 0x8001d1 <HADC>

		ret					// leave subroutine when finished 
 206:	08 95       	ret

00000208 <EEPROM_Write>:

.global EEPROM_Write 

EEPROM_Write:       

		sbic    EECR,EEPE 
 208:	f9 99       	sbic	0x1f, 1	; 31

		rjmp    EEPROM_Write		; Wait for completion of previous write 
 20a:	fe cf       	rjmp	.-4      	; 0x208 <EEPROM_Write>

		ldi	r18,0x00			; Set up address (r18:r17) in address register 
 20c:	20 e0       	ldi	r18, 0x00	; 0

		ldi	r17,0x05  
 20e:	15 e0       	ldi	r17, 0x05	; 5

		ldi	r16,'F'				; Set up data in r16     
 210:	06 e4       	ldi	r16, 0x46	; 70

		out     EEARH, r18       
 212:	22 bd       	out	0x22, r18	; 34

		out     EEARL, r17			       
 214:	11 bd       	out	0x21, r17	; 33

		out     EEDR,r16			; Write data (r16) to Data Register   
 216:	00 bd       	out	0x20, r16	; 32

		sbi     EECR,EEMPE			; Write logical one to EEMPE 
 218:	fa 9a       	sbi	0x1f, 2	; 31

		sbi     EECR,EEPE			; Start eeprom write by setting EEPE 
 21a:	f9 9a       	sbi	0x1f, 1	; 31

		ret  
 21c:	08 95       	ret

0000021e <EEPROM_Read>:

.global EEPROM_Read 

EEPROM_Read:					     

		sbic    EECR,EEPE     
 21e:	f9 99       	sbic	0x1f, 1	; 31

		rjmp    EEPROM_Read		; Wait for completion of previous write 
 220:	fe cf       	rjmp	.-4      	; 0x21e <EEPROM_Read>

		ldi		r18,0x00		; Set up address (r18:r17) in EEPROM address register 
 222:	20 e0       	ldi	r18, 0x00	; 0

		ldi		r17,0x05 
 224:	15 e0       	ldi	r17, 0x05	; 5

		ldi		r16,0x00    
 226:	00 e0       	ldi	r16, 0x00	; 0

		out     EEARH, r18    
 228:	22 bd       	out	0x22, r18	; 34

		out     EEARL, r17		    
 22a:	11 bd       	out	0x21, r17	; 33

		sbi     EECR,EERE		; Start eeprom read by writing EERE 
 22c:	f8 9a       	sbi	0x1f, 0	; 31

		in      r16,EEDR		; Read data from Data Register 
 22e:	00 b5       	in	r16, 0x20	; 32

		sts		ASCII,r16   
 230:	00 93 d2 01 	sts	0x01D2, r16	; 0x8001d2 <ASCII>

		ret 
 234:	08 95       	ret

00000236 <UART_Puts>:

char volts[5];					//string buffer for ADC output
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
 236:	cf 93       	push	r28
 238:	df 93       	push	r29
 23a:	ec 01       	movw	r28, r24
	while (*str)
 23c:	05 c0       	rjmp	.+10     	; 0x248 <UART_Puts+0x12>
	{
		ASCII = *str++;
 23e:	21 96       	adiw	r28, 0x01	; 1
 240:	80 93 d2 01 	sts	0x01D2, r24	; 0x8001d2 <ASCII>
		UART_Put();
 244:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <UART_Put>
char volts[5];					//string buffer for ADC output
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
	while (*str)
 248:	88 81       	ld	r24, Y
 24a:	81 11       	cpse	r24, r1
 24c:	f8 cf       	rjmp	.-16     	; 0x23e <UART_Puts+0x8>
	{
		ASCII = *str++;
		UART_Put();
	}
}
 24e:	df 91       	pop	r29
 250:	cf 91       	pop	r28
 252:	08 95       	ret

00000254 <LCD_Puts>:

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
 254:	cf 93       	push	r28
 256:	df 93       	push	r29
 258:	ec 01       	movw	r28, r24
	while (*str)
 25a:	05 c0       	rjmp	.+10     	; 0x266 <LCD_Puts+0x12>
	{
		DATA = *str++;
 25c:	21 96       	adiw	r28, 0x01	; 1
 25e:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
		LCD_Write_Data();
 262:	0e 94 b3 00 	call	0x166	; 0x166 <LCD_Write_Data>
	}
}

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
	while (*str)
 266:	88 81       	ld	r24, Y
 268:	81 11       	cpse	r24, r1
 26a:	f8 cf       	rjmp	.-16     	; 0x25c <LCD_Puts+0x8>
	{
		DATA = *str++;
		LCD_Write_Data();
	}
}
 26c:	df 91       	pop	r29
 26e:	cf 91       	pop	r28
 270:	08 95       	ret

00000272 <Banner>:


void Banner(void)				//Display Tiny OS Banner on Terminal
{
	UART_Puts(MS1);
 272:	82 eb       	ldi	r24, 0xB2	; 178
 274:	91 e0       	ldi	r25, 0x01	; 1
 276:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	UART_Puts(MS2);
 27a:	8b e7       	ldi	r24, 0x7B	; 123
 27c:	91 e0       	ldi	r25, 0x01	; 1
 27e:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	UART_Puts(MS4);
 282:	80 e5       	ldi	r24, 0x50	; 80
 284:	91 e0       	ldi	r25, 0x01	; 1
 286:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
 28a:	08 95       	ret

0000028c <HELP>:
}

void HELP(void)						//Display available Tiny OS Commands on Terminal
{
	UART_Puts(MS3);
 28c:	8a e5       	ldi	r24, 0x5A	; 90
 28e:	91 e0       	ldi	r25, 0x01	; 1
 290:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
 294:	08 95       	ret

00000296 <LCD>:
}

void LCD(void)						//Lite LCD demo
{
	DATA = 0x34;					//Student Comment Here
 296:	84 e3       	ldi	r24, 0x34	; 52
 298:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
	LCD_Write_Command();
 29c:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x08;					//Student Comment Here
 2a0:	88 e0       	ldi	r24, 0x08	; 8
 2a2:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
	LCD_Write_Command();
 2a6:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x02;					//Student Comment Here
 2aa:	82 e0       	ldi	r24, 0x02	; 2
 2ac:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
	LCD_Write_Command();
 2b0:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x06;					//Student Comment Here
 2b4:	86 e0       	ldi	r24, 0x06	; 6
 2b6:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
	LCD_Write_Command();
 2ba:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x0f;					//Student Comment Here
 2be:	8f e0       	ldi	r24, 0x0F	; 15
 2c0:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
	LCD_Write_Command();
 2c4:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	LCD_Puts("Hello ECE412!");
 2c8:	80 e0       	ldi	r24, 0x00	; 0
 2ca:	91 e0       	ldi	r25, 0x01	; 1
 2cc:	0e 94 2a 01 	call	0x254	; 0x254 <LCD_Puts>
 2d0:	08 95       	ret

000002d2 <ADC>:
	always be able to return to command line.
	*/
}

void ADC(void)						//Lite Demo of the Analog to Digital Converter
{
 2d2:	cf 93       	push	r28
 2d4:	df 93       	push	r29
	volts[0x1]='.';
 2d6:	c3 ed       	ldi	r28, 0xD3	; 211
 2d8:	d1 e0       	ldi	r29, 0x01	; 1
 2da:	8e e2       	ldi	r24, 0x2E	; 46
 2dc:	89 83       	std	Y+1, r24	; 0x01
	volts[0x3]=' ';
 2de:	80 e2       	ldi	r24, 0x20	; 32
 2e0:	8b 83       	std	Y+3, r24	; 0x03
	volts[0x4]= 0;
 2e2:	1c 82       	std	Y+4, r1	; 0x04
	ADC_Get();
 2e4:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <ADC_Get>
	Acc = (((int)HADC) * 0x100 + (int)(LADC))*0xA;
 2e8:	20 91 d1 01 	lds	r18, 0x01D1	; 0x8001d1 <HADC>
 2ec:	30 e0       	ldi	r19, 0x00	; 0
 2ee:	32 2f       	mov	r19, r18
 2f0:	22 27       	eor	r18, r18
 2f2:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <LADC>
 2f6:	28 0f       	add	r18, r24
 2f8:	31 1d       	adc	r19, r1
 2fa:	c9 01       	movw	r24, r18
 2fc:	88 0f       	add	r24, r24
 2fe:	99 1f       	adc	r25, r25
 300:	22 0f       	add	r18, r18
 302:	33 1f       	adc	r19, r19
 304:	22 0f       	add	r18, r18
 306:	33 1f       	adc	r19, r19
 308:	22 0f       	add	r18, r18
 30a:	33 1f       	adc	r19, r19
 30c:	82 0f       	add	r24, r18
 30e:	93 1f       	adc	r25, r19
	volts[0x0] = 48 + (Acc / 0x7FE);
 310:	ee ef       	ldi	r30, 0xFE	; 254
 312:	f7 e0       	ldi	r31, 0x07	; 7
 314:	bf 01       	movw	r22, r30
 316:	0e 94 01 02 	call	0x402	; 0x402 <__divmodhi4>
 31a:	20 e3       	ldi	r18, 0x30	; 48
 31c:	26 0f       	add	r18, r22
 31e:	28 83       	st	Y, r18
	Acc = Acc % 0x7FE;
	volts[0x2] = ((Acc *0xA) / 0x7FE) + 48;
 320:	ac 01       	movw	r20, r24
 322:	44 0f       	add	r20, r20
 324:	55 1f       	adc	r21, r21
 326:	88 0f       	add	r24, r24
 328:	99 1f       	adc	r25, r25
 32a:	88 0f       	add	r24, r24
 32c:	99 1f       	adc	r25, r25
 32e:	88 0f       	add	r24, r24
 330:	99 1f       	adc	r25, r25
 332:	84 0f       	add	r24, r20
 334:	95 1f       	adc	r25, r21
 336:	bf 01       	movw	r22, r30
 338:	0e 94 01 02 	call	0x402	; 0x402 <__divmodhi4>
 33c:	60 5d       	subi	r22, 0xD0	; 208
 33e:	6a 83       	std	Y+2, r22	; 0x02
	Acc = (Acc * 0xA) % 0x7FE;
 340:	90 93 da 01 	sts	0x01DA, r25	; 0x8001da <Acc+0x1>
 344:	80 93 d9 01 	sts	0x01D9, r24	; 0x8001d9 <Acc>
	if (Acc >= 0x3FF) volts[0x2]++;
 348:	8f 3f       	cpi	r24, 0xFF	; 255
 34a:	93 40       	sbci	r25, 0x03	; 3
 34c:	1c f0       	brlt	.+6      	; 0x354 <ADC+0x82>
 34e:	6f 5f       	subi	r22, 0xFF	; 255
 350:	60 93 d5 01 	sts	0x01D5, r22	; 0x8001d5 <volts+0x2>
	if (volts[0x2] == 58)
 354:	80 91 d5 01 	lds	r24, 0x01D5	; 0x8001d5 <volts+0x2>
 358:	8a 33       	cpi	r24, 0x3A	; 58
 35a:	31 f4       	brne	.+12     	; 0x368 <ADC+0x96>
	{
		volts[0x2] = 48;
 35c:	e3 ed       	ldi	r30, 0xD3	; 211
 35e:	f1 e0       	ldi	r31, 0x01	; 1
 360:	80 e3       	ldi	r24, 0x30	; 48
 362:	82 83       	std	Z+2, r24	; 0x02
		volts[0x0]++;
 364:	2f 5f       	subi	r18, 0xFF	; 255
 366:	20 83       	st	Z, r18
	}
	UART_Puts(volts);
 368:	83 ed       	ldi	r24, 0xD3	; 211
 36a:	91 e0       	ldi	r25, 0x01	; 1
 36c:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	UART_Puts(MS6);
 370:	8a e2       	ldi	r24, 0x2A	; 42
 372:	91 e0       	ldi	r25, 0x01	; 1
 374:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		The potentiometer simulates a thermistor, its varying resistance simulates the
		varying resistance of a thermistor as it is heated and cooled. See the thermistor
		equations in the lab 3 folder. User must always be able to return to command line.
	*/
	
}
 378:	df 91       	pop	r29
 37a:	cf 91       	pop	r28
 37c:	08 95       	ret

0000037e <EEPROM>:

void EEPROM(void)
{
	UART_Puts("\r\nEEPROM Write and Read.");
 37e:	8e e0       	ldi	r24, 0x0E	; 14
 380:	91 e0       	ldi	r25, 0x01	; 1
 382:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	during run-time via the command line and the same byte of data can be read back and verified after the power to
	the Xplained Mini board has been cycled. Ask the user to enter a valid EEPROM address and an
	8-bit data value. Utilize the following two given Assembly based drivers to communicate with the EEPROM. You
	may modify the EEPROM drivers as needed. User must be able to always return to command line.
	*/
	UART_Puts("\r\n");
 386:	87 e2       	ldi	r24, 0x27	; 39
 388:	91 e0       	ldi	r25, 0x01	; 1
 38a:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	EEPROM_Write();
 38e:	0e 94 04 01 	call	0x208	; 0x208 <EEPROM_Write>
	UART_Puts("\r\n");
 392:	87 e2       	ldi	r24, 0x27	; 39
 394:	91 e0       	ldi	r25, 0x01	; 1
 396:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	EEPROM_Read();
 39a:	0e 94 0f 01 	call	0x21e	; 0x21e <EEPROM_Read>
	UART_Put();
 39e:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <UART_Put>
	UART_Puts("\r\n");
 3a2:	87 e2       	ldi	r24, 0x27	; 39
 3a4:	91 e0       	ldi	r25, 0x01	; 1
 3a6:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
 3aa:	08 95       	ret

000003ac <Command>:
}


void Command(void)					//command interpreter
{
	UART_Puts(MS3);
 3ac:	8a e5       	ldi	r24, 0x5A	; 90
 3ae:	91 e0       	ldi	r25, 0x01	; 1
 3b0:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	ASCII = '\0';						
 3b4:	10 92 d2 01 	sts	0x01D2, r1	; 0x8001d2 <ASCII>
	while (ASCII == '\0')
 3b8:	02 c0       	rjmp	.+4      	; 0x3be <Command+0x12>
	{
		UART_Get();
 3ba:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>

void Command(void)					//command interpreter
{
	UART_Puts(MS3);
	ASCII = '\0';						
	while (ASCII == '\0')
 3be:	80 91 d2 01 	lds	r24, 0x01D2	; 0x8001d2 <ASCII>
 3c2:	88 23       	and	r24, r24
 3c4:	d1 f3       	breq	.-12     	; 0x3ba <Command+0xe>
	{
		UART_Get();
	}
	switch (ASCII)
 3c6:	85 36       	cpi	r24, 0x65	; 101
 3c8:	59 f0       	breq	.+22     	; 0x3e0 <Command+0x34>
 3ca:	8c 36       	cpi	r24, 0x6C	; 108
 3cc:	19 f0       	breq	.+6      	; 0x3d4 <Command+0x28>
 3ce:	81 36       	cpi	r24, 0x61	; 97
 3d0:	51 f4       	brne	.+20     	; 0x3e6 <Command+0x3a>
 3d2:	03 c0       	rjmp	.+6      	; 0x3da <Command+0x2e>
	{
		case 'L' | 'l': LCD();
 3d4:	0e 94 4b 01 	call	0x296	; 0x296 <LCD>
		break;
 3d8:	08 95       	ret
		case 'A' | 'a': ADC();
 3da:	0e 94 69 01 	call	0x2d2	; 0x2d2 <ADC>
		break;
 3de:	08 95       	ret
		case 'E' | 'e': EEPROM();
 3e0:	0e 94 bf 01 	call	0x37e	; 0x37e <EEPROM>
		break;
 3e4:	08 95       	ret
		default:
		UART_Puts(MS5);
 3e6:	81 e3       	ldi	r24, 0x31	; 49
 3e8:	91 e0       	ldi	r25, 0x01	; 1
 3ea:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		HELP();
 3ee:	0e 94 46 01 	call	0x28c	; 0x28c <HELP>
 3f2:	08 95       	ret

000003f4 <main>:
	}
}

int main(void)
{
	Mega328P_Init();
 3f4:	0e 94 79 00 	call	0xf2	; 0xf2 <Mega328P_Init>
	Banner();
 3f8:	0e 94 39 01 	call	0x272	; 0x272 <Banner>
	while (1)
	{
		Command();				//infinite command loop
 3fc:	0e 94 d6 01 	call	0x3ac	; 0x3ac <Command>
 400:	fd cf       	rjmp	.-6      	; 0x3fc <main+0x8>

00000402 <__divmodhi4>:
 402:	97 fb       	bst	r25, 7
 404:	07 2e       	mov	r0, r23
 406:	16 f4       	brtc	.+4      	; 0x40c <__divmodhi4+0xa>
 408:	00 94       	com	r0
 40a:	07 d0       	rcall	.+14     	; 0x41a <__divmodhi4_neg1>
 40c:	77 fd       	sbrc	r23, 7
 40e:	09 d0       	rcall	.+18     	; 0x422 <__divmodhi4_neg2>
 410:	0e 94 15 02 	call	0x42a	; 0x42a <__udivmodhi4>
 414:	07 fc       	sbrc	r0, 7
 416:	05 d0       	rcall	.+10     	; 0x422 <__divmodhi4_neg2>
 418:	3e f4       	brtc	.+14     	; 0x428 <__divmodhi4_exit>

0000041a <__divmodhi4_neg1>:
 41a:	90 95       	com	r25
 41c:	81 95       	neg	r24
 41e:	9f 4f       	sbci	r25, 0xFF	; 255
 420:	08 95       	ret

00000422 <__divmodhi4_neg2>:
 422:	70 95       	com	r23
 424:	61 95       	neg	r22
 426:	7f 4f       	sbci	r23, 0xFF	; 255

00000428 <__divmodhi4_exit>:
 428:	08 95       	ret

0000042a <__udivmodhi4>:
 42a:	aa 1b       	sub	r26, r26
 42c:	bb 1b       	sub	r27, r27
 42e:	51 e1       	ldi	r21, 0x11	; 17
 430:	07 c0       	rjmp	.+14     	; 0x440 <__udivmodhi4_ep>

00000432 <__udivmodhi4_loop>:
 432:	aa 1f       	adc	r26, r26
 434:	bb 1f       	adc	r27, r27
 436:	a6 17       	cp	r26, r22
 438:	b7 07       	cpc	r27, r23
 43a:	10 f0       	brcs	.+4      	; 0x440 <__udivmodhi4_ep>
 43c:	a6 1b       	sub	r26, r22
 43e:	b7 0b       	sbc	r27, r23

00000440 <__udivmodhi4_ep>:
 440:	88 1f       	adc	r24, r24
 442:	99 1f       	adc	r25, r25
 444:	5a 95       	dec	r21
 446:	a9 f7       	brne	.-22     	; 0x432 <__udivmodhi4_loop>
 448:	80 95       	com	r24
 44a:	90 95       	com	r25
 44c:	bc 01       	movw	r22, r24
 44e:	cd 01       	movw	r24, r26
 450:	08 95       	ret

00000452 <_exit>:
 452:	f8 94       	cli

00000454 <__stop_program>:
 454:	ff cf       	rjmp	.-2      	; 0x454 <__stop_program>
